https://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=185139

"Mc" name
@article{McBride:2003:first-order:10.1017/S0956796803004957,
  author = {McBride, Conor},
  affiliation = {University of Durham},
  title = {First-order unification by structural recursion},
  journal = {Journal of Functional Programming},
  volume = {13},
  number = {6},
  pages = {1061--1075},
  month = nov,
  year = {2003},
  publisher = {Cambridge University Press},
  issn = {0956-7968 (Print) 1469-7653 (Online)},
  doi = {10.1017/S0956796803004957},
  bib_scrape_url = {https://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=185139},
  abstract = {First-order unification algorithms (Robinson, 1965) are traditionally implemented via general recursion, with separate proofs for partial correctness and termination. The latter tends to involve counting the number of unsolved variables and showing that this total decreases each time a substitution enlarges the terms. There are many such proofs in the literature (Manna {\&} Waldinger, 1981; Paulson, 1985; Coen, 1992; Rouyer, 1992; Jaume, 1997; Bove, 1999). This paper shows how a dependent type can relate terms to the set of variables over which they are constructed. As a consequence, first-order unification becomes a structurally recursive program, and a termination proof is no longer required. Both the program and its correctness proof have been checked using the proof assistant L\textsc{EGO} (Luo {\&} Pollack, 1992; McBride, 1999).},
}
