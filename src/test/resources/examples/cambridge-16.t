https://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=7524488

Capitals in title "C-Rules"
@article{Wazny:2010:experience:10.1017/S0956796810000018,
  author = {Wazny, Jeremy},
  title = {Experience report: Functional programming in {C}-Rules},
  journal = {Journal of Functional Programming},
  volume = {20},
  number = {2},
  pages = {123--136},
  month = mar,
  year = {2010},
  publisher = {Cambridge University Press},
  issn = {0956-7968 (Print) 1469-7653 (Online)},
  doi = {10.1017/S0956796810000018},
  bib_scrape_url = {https://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=7524488},
  abstract = {C-Rules is a business rules management system developed by Constraint Technologies International (www.constrainttechnologies.com) that is designed for use in transport, travel and logistics problems. Individual businesses within these industries often need to solve the same kinds of problems related to scheduling of operations, resource allocation, staff rostering and so on, but each organisation has its own rules and procedures. Furthermore, these problems tend to be combinatorially challenging: before a final solution is chosen, many potential choices need to be generated, evaluated and compared. In C-Rules, users define rules that describe various aspects of a problem. These rules can be invoked from an application, which is typically either an optimising solver or an interactive planning tool. Rules can be used to encode evaluation criteria, such as the legality or cost of a proposed solution, or values like configuration parameters that may be used by the host application to tune or direct its progress. At its core, C-Rules provides a functional expression language that affords users power and flexibility when formulating rules. In this paper we will describe our experiences of using functional programming both at the end-user level and at the implementation level. We highlight some of the benefits of basing our rule system on features such as higher-order functions, referential transparency and static, polymorphic typing. We also outline some of our experiences in using Haskell to build an efficient compiler for the core language.},
}
